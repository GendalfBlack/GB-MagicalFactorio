using System.Collections.Generic;
using System.Linq;

public class VoronoiGenerator
{
    #region Data Structures
    /// <summary>
    /// Represents a seed with a unique identifier and coordinates in a two-dimensional space.
    /// </summary>
    /// <remarks>The <see cref="Seed"/> struct is used to define a point in a two-dimensional space, 
    /// identified by its unique <see cref="id"/> and its <see cref="x"/> and <see cref="y"/> coordinates.
    /// Coordinates are not necessarily the center of a region, but rather the origin point for Voronoi calculations.
    /// </remarks>
    public struct Seed
    {
        /// <summary>
        /// Represents the unique identifier for a region cell.
        /// </summary>
        public int id;
        /// <summary>
        /// Represents the x-coordinate of a point in a two-dimensional space. Not a center, just coordinate origin.
        /// </summary>
        public float x;
        /// <summary>
        /// Represents the y-coordinate of a point in a two-dimensional space. Not a center, just coordinate origin.
        /// </summary>
        public float y;
    }


    /// <summary>
    /// Represents the result of a Voronoi diagram computation, including seeds, a region map, and region details.
    /// </summary>
    /// <remarks>This structure encapsulates the data generated by a Voronoi diagram computation. It includes:
    /// <list type="bullet"> 
    ///     <item> 
    ///         <description><see cref="seeds"/>: The array of seeds used to initialize or configure
    /// the Voronoi diagram.</description> 
    ///     </item> 
    ///     <item> 
    ///         <description><see cref="regionMap"/>: A two-dimensional array
    /// representing the map of regions, where each value corresponds to a region identifier.</description> 
    ///     </item>
    ///     <item> 
    ///         <description><see cref="regions"/>: A dictionary mapping region identifiers to their respective lists of
    /// coordinate points.</description> 
    ///     </item> 
    ///</list>
    ///     This structure is typically used to analyze or visualize the results of
    /// Voronoi diagram computations.</remarks>
    public struct VoronoiResult
    {
        /// <summary>
        /// An array of seeds used for initializing or configuring the object.
        /// </summary>
        /// <remarks>Each element in the array represents a seed, which may be used for purposes such as
        /// random number generation,  data initialization, or other configurable operations. Ensure the array is
        /// properly populated before use.</remarks>
        public Seed[] seeds;
        /// <summary>
        /// Represents a two-dimensional array that defines a map of regions.
        /// </summary>
        /// <remarks>Each element in the array corresponds to a specific region, where the value at a
        /// given position represents the identifier or classification of that region. The dimensions of the array
        /// determine the size of the map.</remarks>
        public int[,] regionMap;
        /// <summary>
        /// Represents a collection of regions, where each region is identified by an integer key and contains a list of
        /// coordinate pairs.
        /// </summary>
        /// <remarks>Each region is represented as a list of tuples, where each tuple contains two
        /// integers representing the x and y coordinates of a point within the region.</remarks>
        public Dictionary<int, List<(int x, int y)>> regions;
    }
    #endregion

    #region Public Methods
    /// <summary>
    /// Generates a Voronoi diagram based on the specified dimensions, cell count, and random seed.
    /// </summary>
    /// <remarks>The Voronoi diagram is generated by dividing the specified area into regions based on the
    /// proximity of points (seeds) randomly distributed across the area. The random seed parameter allows for
    /// reproducible results when generating diagrams.</remarks>
    /// <param name="width">The width of the diagram, in pixels. Must be greater than 0.</param>
    /// <param name="height">The height of the diagram, in pixels. Must be greater than 0.</param>
    /// <param name="cellCount">The number of cells (regions) to generate. Must be greater than 0.</param>
    /// <param name="randomSeed">An optional seed value for the random number generator. If set to 0, a random seed will be used.</param>
    /// <returns>A <see cref="VoronoiResult"/> object containing the seeds, region map, and region lists that define the
    /// generated Voronoi diagram.</returns>
    public static VoronoiResult Generate(int width, int height, int cellCount, int randomSeed = 0)
    {
        var rng = (randomSeed == 0)
            ? new System.Random()
            : new System.Random(randomSeed);

        Seed[] seeds = GenerateSeeds(width, height, cellCount, rng);
        int[,] regionMap = BuildVoronoiMap(width, height, seeds);
        var regions = BuildRegionLists(width, height, regionMap);

        return new VoronoiResult
        {
            seeds = seeds,
            regionMap = regionMap,
            regions = regions
        };
    }


    /// <summary>
    /// Merges small regions in a Voronoi diagram into neighboring regions to ensure all regions meet a minimum pixel
    /// count.
    /// </summary>
    /// <remarks>This method modifies the <paramref name="result"/> by merging regions with fewer pixels than
    /// <paramref name="minRegionPixelCount"/>  into randomly selected neighboring regions. If a region has no
    /// neighbors, it will remain unmerged.  After merging, the region map and region lists in <paramref name="result"/>
    /// are updated to reflect the changes.</remarks>
    /// <param name="result">The <see cref="VoronoiResult"/> containing the regions and region map to be modified.  This parameter is passed
    /// by reference and will be updated with the merged regions.</param>
    /// <param name="width">The width of the region map, in pixels.</param>
    /// <param name="height">The height of the region map, in pixels.</param>
    /// <param name="minRegionPixelCount">The minimum number of pixels required for a region to remain unmerged. Regions with fewer pixels will be merged
    /// into neighboring regions. Must be greater than 1.</param>
    /// <param name="randomSeed">An optional seed value for the random number generator used to select neighboring regions during merging.  If
    /// set to 0, a non-deterministic random generator will be used. Defaults to 0.</param>
    public static void MergeSmallRegions(
        ref VoronoiResult result,
        int width,
        int height,
        int minRegionPixelCount,
        int randomSeed = 0
    )
    {
        if (minRegionPixelCount <= 1) return;

        var rng = (randomSeed == 0)
            ? new System.Random()
            : new System.Random(randomSeed);

        // We'll collect ids to process so we can iterate stable
        // (because we'll be editing the dict as we go).
        var allRegionIds = new List<int>(result.regions.Keys);

        foreach (var regionId in allRegionIds)
        {
            // region might already be merged/removed
            if (!result.regions.TryGetValue(regionId, out var pixels))
                continue;

            if (pixels.Count >= minRegionPixelCount)
                continue; // big enough, leave it

            // 1. find neighbor region candidates
            var neighborIds = FindNeighborRegions(result.regionMap, pixels, width, height, regionId);

            if (neighborIds.Count == 0)
            {
                // isolated island with no neighbors (can basically happen only with full map of 1 cell)
                continue;
            }

            // pick random neighbor
            int mergeTarget = neighborIds[rng.Next(neighborIds.Count)];

            // 2. reassign all pixels of this tiny region to mergeTarget
            if (!result.regions.TryGetValue(mergeTarget, out var targetPixels))
            {
                targetPixels = new List<(int x, int y)>();
                result.regions[mergeTarget] = targetPixels;
            }

            foreach (var (px, py) in pixels)
            {
                result.regionMap[px, py] = mergeTarget;
                targetPixels.Add((px, py));
            }

            // 3. remove the small region
            result.regions.Remove(regionId);
        }

        // Optional cleanup pass:
        // after merging we technically could rebuild regions from scratch
        // to be 100% consistent. Safe & simple:
        result.regions = BuildRegionLists(width, height, result.regionMap);
    }
    #endregion

    #region Private Methods
    /// <summary>
    /// Generates an array of seeds with random positions within the specified dimensions.
    /// </summary>
    /// <param name="width">The width of the area within which the seeds will be generated. Must be a positive value.</param>
    /// <param name="height">The height of the area within which the seeds will be generated. Must be a positive value.</param>
    /// <param name="cellCount">The number of seeds to generate. Must be a non-negative value.</param>
    /// <param name="rng">The random number generator used to determine the positions of the seeds. Cannot be <see langword="null"/>.</param>
    /// <returns>An array of <see cref="Seed"/> objects, each with a unique identifier and random position within the specified
    /// dimensions.</returns>
    static Seed[] GenerateSeeds(int width, int height, int cellCount, System.Random rng)
    {
        var seeds = new Seed[cellCount];
        for (int i = 0; i < cellCount; i++)
        {
            seeds[i] = new Seed
            {
                id = i,
                x = (float)rng.NextDouble() * width,
                y = (float)rng.NextDouble() * height
            };
        }
        return seeds;
    }


    /// <summary>
    /// Generates a Voronoi map by assigning each point in a grid to the nearest seed based on Euclidean distance.
    /// </summary>
    /// <remarks>If multiple seeds are equidistant to a grid cell, the seed that appears first in the
    /// <paramref name="seeds"/> array is chosen. The method assumes that the <paramref name="seeds"/> array is not null
    /// and contains at least one seed.</remarks>
    /// <param name="width">The width of the grid, in number of cells. Must be greater than 0.</param>
    /// <param name="height">The height of the grid, in number of cells. Must be greater than 0.</param>
    /// <param name="seeds">An array of <see cref="Seed"/> objects representing the points of origin for the Voronoi regions. Each seed must
    /// have a unique identifier.</param>
    /// <returns>A two-dimensional array of integers representing the Voronoi map. Each cell contains the identifier of the seed
    /// to which it is closest. The array dimensions match the specified <paramref name="width"/> and <paramref
    /// name="height"/>.</returns>
    static int[,] BuildVoronoiMap(int width, int height, Seed[] seeds)
    {
        int[,] regionMap = new int[width, height];

        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                int closestSeedId = -1;
                float closestDistSq = float.MaxValue;

                for (int i = 0; i < seeds.Length; i++)
                {
                    float dx = x - seeds[i].x;
                    float dy = y - seeds[i].y;
                    float distSq = dx * dx + dy * dy;

                    if (distSq < closestDistSq)
                    {
                        closestDistSq = distSq;
                        closestSeedId = seeds[i].id;
                    }
                }

                regionMap[x, y] = closestSeedId;
            }
        }

        return regionMap;
    }


    static Dictionary<int, List<(int x, int y)>> BuildRegionLists(int width, int height, int[,] regionMap)
    {
        var regions = new Dictionary<int, List<(int x, int y)>>();

        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                int regionId = regionMap[x, y];
                if (!regions.TryGetValue(regionId, out var list))
                {
                    list = new List<(int x, int y)>();
                    regions[regionId] = list;
                }
                list.Add((x, y));
            }
        }

        return regions;
    }

    // collect all neighbor region IDs touching this region's pixels (4-neighborhood)
    static List<int> FindNeighborRegions(
        int[,] regionMap,
        List<(int x, int y)> pixels,
        int width,
        int height,
        int selfId
    )
    {
        var neighborSet = new HashSet<int>();

        foreach (var (x, y) in pixels)
        {
            // check 4 dirs
            TryAdd(regionMap, x + 1, y, width, height, selfId, neighborSet);
            TryAdd(regionMap, x - 1, y, width, height, selfId, neighborSet);
            TryAdd(regionMap, x, y + 1, width, height, selfId, neighborSet);
            TryAdd(regionMap, x, y - 1, width, height, selfId, neighborSet);
        }

        return new List<int>(neighborSet);
    }

    static void TryAdd(int[,] map, int x, int y, int w, int h, int selfId, HashSet<int> set)
    {
        if (x < 0 || x >= w || y < 0 || y >= h)
            return;
        int id = map[x, y];
        if (id != selfId)
            set.Add(id);
    }
    #endregion
}
