using UnityEngine;

/// <summary>
/// A Unity component for generating Voronoi diagrams with configurable dimensions, cell count, and optional
/// post-processing.
/// </summary>
/// <remarks>This component allows users to generate Voronoi diagrams with customizable width, height, and cell
/// count.  Optionally, small regions in the diagram can be merged into neighboring regions based on a minimum pixel
/// count threshold.  The generated Voronoi diagram is output as a texture, which can be used in various applications
/// such as procedural  content generation or visualization. If a <see cref="WorldSeedComponent"/> is assigned to the
/// <c>seedSource</c> field,  its seed value will be used for deterministic generation; otherwise, a default seed of 0
/// is applied.</remarks>
[ExecuteInEditMode]
public class VoronoiComponent : MonoBehaviour
{
    VoronoiGenerator.VoronoiResult lastResult;

    #region Inspector Fields
    [Header("Sources (auto)")]
    [Tooltip("Optional WorldSeedComponent to provide a seed for Voronoi generation.")]
    public WorldSeedComponent seedSource;

    [Header("Voronoi Settings")]
    [Min(2)]
    [Tooltip("Width of the generated Voronoi map, in pixels.")]
    public int width = 512;

    [Min(2)]
    [Tooltip("Height of the generated Voronoi map, in pixels.")]
    public int height = 512;

    [Min(2)]
    [Tooltip("Number of Voronoi cells to generate.")]
    public int cellCount = 50;

    [Header("Post-process Small Cells")]
    [Tooltip("If enabled, regions smaller than 'minRegionPixelCount' will be merged into neighboring regions.")]
    public bool mergeSmallRegions = true;

    [Min(1)]
    [Tooltip("The minimum number of pixels a region must have to avoid being merged into a neighboring region.")]
    public int minRegionPixelCount = 6000;

    [Header("Output (read-only)")]
    [Tooltip("The generated Voronoi texture.")]
    public Texture2D generatedTexture;
    #endregion

    #region Public Methods
    /// <summary>
    /// Retrieves the most recent result generated by the Voronoi diagram computation.
    /// </summary>
    /// <returns>The last computed <see cref="VoronoiGenerator.VoronoiResult"/> instance, or <see langword="null"/> if no result
    /// has been generated.</returns>
    public VoronoiGenerator.VoronoiResult GetLastResult()
    {
        if (lastResult.regionMap == null)
        {
            Debug.LogWarning("VoronoiComponent: no last result available.");
        }
        return lastResult;
    }


    /// <summary>
    /// Generates a Voronoi map based on the specified dimensions, cell count, and seed.
    /// </summary>
    /// <remarks>This method creates a Voronoi map using the configured width, height, and cell count.  If a
    /// seed source is available, its seed value is used; otherwise, a default seed of 0 is applied.  Optionally, small
    /// regions in the map can be merged if the <c>mergeSmallRegions</c> flag is set  and <c>minRegionPixelCount</c> is
    /// greater than 1. The resulting map is baked into a texture  for further use.</remarks>
    public void CreateVoronoiMap()
    {
        int seedToUse = 0;
        if (!CanGenerate(out seedToUse))
        {
            return;
        }

        // 1. Base Voronoi
        lastResult = VoronoiGenerator.Generate(width, height, cellCount, seedToUse);

        // 2. Optional post-process merge of tiny regions
        if (mergeSmallRegions && minRegionPixelCount > 1)
        {
            VoronoiGenerator.MergeSmallRegions(
                ref lastResult,
                width,
                height,
                minRegionPixelCount,
                seedToUse
            );
        }

        // 3. Bake texture
        generatedTexture = BuildTextureFromRegionMap(lastResult.regionMap, width, height);

#if UNITY_EDITOR
        UnityEditor.EditorUtility.SetDirty(this);
#endif
    }
    #endregion

    #region Private Methods
    /// <summary>
    /// Determines whether generation can proceed based on the current configuration and provides a seed value.
    /// </summary>
    /// <remarks>If no seed source is found, a warning is logged, and the seed value defaults to 0.</remarks>
    /// <param name="seed">When this method returns, contains the seed value to be used for generation. If no seed source is available, the
    /// value will be 0.</param>
    /// <returns><see langword="true"/> if the generation can proceed; otherwise, <see langword="false"/>. Generation is possible
    /// if the width and height are greater than 1, and the cell count is greater than 0.</returns>
    bool CanGenerate(out int seed)
    {
        if (seedSource == null)
        {
            seedSource = GetComponent<WorldSeedComponent>();
        }

        seed = 0;

        if (seedSource != null)
        {
            seed = seedSource.worldSeed;
        }
        else
        {
            Debug.LogWarning("No seed source was founded, but was expected. Passing 0 as default.");
        }

        return width > 1 && height > 1 && cellCount > 0;
    }

    /// <summary>
    /// Builds a texture from a region map, where each region is represented by a unique identifier.
    /// </summary>
    /// <remarks>The method assigns a random color to each unique region identifier in the region map. The
    /// resulting texture uses a point filter mode  and a clamp wrap mode. The texture is created with the RGBA32 format
    /// and is ready for use after being returned.</remarks>
    /// <param name="regionMap">A two-dimensional array representing the region map. Each element corresponds to a region identifier for a
    /// specific tile.</param>
    /// <param name="w">The width of the texture, in pixels.</param>
    /// <param name="h">The height of the texture, in pixels.</param>
    /// <returns>A <see cref="Texture2D"/> object where each tile's color is determined by the region identifier in the <paramref
    /// name="regionMap"/>.</returns>
    Texture2D BuildTextureFromRegionMap(int[,] regionMap, int w, int h)
    {
        Color[] pixels = new Color[w * h];

        for (int y = 0; y < h; y++)
        {
            for (int x = 0; x < w; x++)
            {
                int regionId = regionMap[x, y];
                pixels[y * w + x] = PickRandomColorForTile(regionId);
            }
        }

        Texture2D tex = new Texture2D(w, h, TextureFormat.RGBA32, false);
        tex.filterMode = FilterMode.Point;
        tex.wrapMode = TextureWrapMode.Clamp;
        tex.SetPixels(pixels);
        tex.Apply();

        return tex;
    }


    /// <summary>
    /// Generates a pseudo-random color based on the specified tile identifier.
    /// </summary>
    /// <remarks>The generated color is deterministic for a given <paramref name="id"/>, meaning the same
    /// identifier will always produce the same color. This method ensures that the resulting color is visually distinct
    /// by applying a brightness adjustment.</remarks>
    /// <param name="id">The unique identifier of the tile used to generate the color.</param>
    /// <returns>A <see cref="Color"/> instance representing the generated color. The color is fully opaque and has a slight
    /// brightness boost applied.</returns>
    Color PickRandomColorForTile(int id)
    {
        unchecked
        {
            int hash = (int)(id * 92837111 ^ 0x9E3779B9);
            byte r = (byte)((hash >> 16) & 0xFF);
            byte g = (byte)((hash >> 8) & 0xFF);
            byte b = (byte)(hash & 0xFF);

            float fr = (r / 255f);
            float fg = (g / 255f);
            float fb = (b / 255f);

            float boost = 0.3f;
            fr = Mathf.Clamp01(fr * 0.7f + boost);
            fg = Mathf.Clamp01(fg * 0.7f + boost);
            fb = Mathf.Clamp01(fb * 0.7f + boost);

            return new Color(fr, fg, fb, 1f);
        }
    }
    #endregion
}
